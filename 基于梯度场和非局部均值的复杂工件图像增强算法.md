# 基于梯度场和非局部均值的复杂工件图像增强算法



没问题。下面给你一份**可直接落地到你现有 DICOM 图像管线的实现文档（Python 版）**。我把论文里的三个核心步骤（梯度场自适应增强 → 泊松分布的非局部均值在梯度域去噪 → 变分重建）拆成独立函数，并给出默认参数（用文中推荐值），方便你在框架里按需调用/替换。

> 关键公式出处我都贴了行号，便于你校对原文。
>  记号：输入图像 RR（二维，灰度）；∇R\nabla R 为梯度；σ2\sigma^2 为局部方差；G′G' 为增强后梯度场，GG 为去噪后的梯度场；最终重建 II。

------

# 1) 依赖与输入约定

- 仅用到：`numpy`、`cv2`（可选，用来做盒滤波更快；不用也可以全 numpy）
- 输入：你已有的 DICOM 加载模块产出 **2D numpy 数组**（`uint16`/`float32` 均可）。代码内部会做归一化。

```bash
pip install numpy opencv-python
```

------

# 2) 实现概览（对应论文三步）

- **Step 1：梯度场 + 局部方差的自适应增强**
   先取梯度作为对比度度量 CR(p)=∇R(p)C_R(p)=\nabla R(p)（式(1)），在 ∣∇R∣>ε|\nabla R|>\varepsilon 处按增益 kk 放大（式(2)），
   原文先给了随梯度幅值的 k(∥∇R∥)k(\|\nabla R\|)（式(3)），但其对噪声敏感，于是改为**随局部方差**的 k(σ2)k(\sigma^2)（式(5)），并以此重定义增强梯度场 G′G'（式(6)）。
   公式出处：   
- **Step 2：基于泊松分布的非局部均值（NLM）在梯度域去噪**
   因 X 射线图像含泊松噪声（式(7)），在非局部相似集合上用极大似然估计 λ^\hat\lambda（式(8)），以分布距离 d(λx,λy)d(\lambda_x,\lambda_y)（式(9)(10)）做权重（式(11)(12)），对 G′G' 平滑得到 GG。
   公式出处：  
- **Step 3：变分重建**
   最小化 E(I)=γ ⁣∬∥∇I∥+δ ⁣∬∥∇I−G∥2E(I)=\gamma\!\iint \|\nabla I\| + \delta\!\iint \|\nabla I - G\|^2（式(13)），欧拉–拉格朗日方程（式(14)）用**梯度下降**（式(15)）迭代，像素裁剪到 [0,255][0,255]（式(16)）。
   公式出处：   

> 文中给的实测**默认参数**：迭代 n=10n=10，ε=2.3\varepsilon=2.3，μ=10\mu=10，ρ=1.5\rho=1.5，γ=0.2\gamma=0.2，δ=0.8\delta=0.8（MATLAB R2019a，R7-5800H）。

------

# 3) 代码（可直接粘用）

```python
import numpy as np
import cv2

# ---------- 工具函数 ----------
def _normalize_to_255(img):
    img = img.astype(np.float32)
    vmin, vmax = np.percentile(img, [0.5, 99.5])  # 稳健归一
    if vmax <= vmin:
        vmax = img.max() if img.max() > vmin else (vmin + 1.0)
    out = (img - vmin) / (vmax - vmin)
    out = np.clip(out, 0, 1) * 255.0
    return out

def _grad2d(img):
    # 中心差分（也可换 Sobel）
    gx = 0.5 * (np.roll(img, -1, axis=1) - np.roll(img, 1, axis=1))
    gy = 0.5 * (np.roll(img, -1, axis=0) - np.roll(img, 1, axis=0))
    return gx, gy

def _div2d(px, py):
    # 散度：p = (px, py)
    dx = 0.5 * (np.roll(px, -1, axis=1) - np.roll(px, 1, axis=1))
    dy = 0.5 * (np.roll(py, -1, axis=0) - np.roll(py, 1, axis=0))
    return dx + dy

def _laplace(img):
    return (np.roll(img, -1, 0) + np.roll(img, 1, 0) + np.roll(img, -1, 1) + np.roll(img, 1, 1) - 4*img)

def _local_variance(img, ksize=5):
    # 盒滤波计算均值与平方均值：σ^2 = E[x^2] - (E[x])^2
    if ksize % 2 == 0: ksize += 1
    kernel = (ksize, ksize)
    mean = cv2.blur(img, kernel=kernel, borderType=cv2.BORDER_REFLECT)
    mean2 = cv2.blur(img*img, kernel=kernel, borderType=cv2.BORDER_REFLECT)
    var = np.clip(mean2 - mean*mean, 0, None)
    return var

# ---------- Step 1：梯度场 + 局部方差的自适应增强 ----------
def adaptive_gradient_enhance(R,
                              epsilon=2.3,  # ε（式(2)(6)）
                              mu=10.0,      # μ（式(5)）
                              ksize=5):
    """
    输入 R：任意范围的 2D 图像（uint16/float）
    返回：Gx_prime, Gy_prime（增强后的梯度场 G'）
    """
    # 归一化到[0,255]，与论文阈值/参数量级匹配
    Rn = _normalize_to_255(R)

    # 梯度（式(1)）
    gx, gy = _grad2d(Rn)
    grad_mag = np.sqrt(gx*gx + gy*gy)

    # 局部方差 σ^2（式(4)）
    sigma2 = _local_variance(Rn, ksize=ksize)
    sigma = np.sqrt(sigma2 + 1e-6)

    # 增益系数 k(σ^2)（式(5)）
    # C 取 σ 的 90%分位（也可按原文式(3)用梯度分位，二者量纲一致时效果接近）
    C = np.percentile(sigma, 90.0) + 1e-6
    k = (1.0 + mu) / (1.0 + (sigma / C)**2)

    # 增强梯度场（式(6)）：σ^2 > ε 时放大，否则置0
    mask = (sigma2 > epsilon).astype(np.float32)
    Gx_prime = k * gx * mask
    Gy_prime = k * gy * mask
    return Gx_prime, Gy_prime

# ---------- Step 2：泊松分布的非局部均值（NLM）在梯度域 ----------
def poisson_nlm_on_gradient(Gx_prime, Gy_prime,
                            search_radius=5,   # 搜索窗半径（共 2r+1）
                            patch_radius=1,    # patch 半径（共 2r+1）
                            topk=25,           # 取最相似的 k 个
                            rho=1.5,           # ρ（式(12)）
                            count_scale=0.5):
    """
    论文在梯度域做 Poisson-NLM。为保证泊松“非负计数”的建模，
    我们对 |G'| 做缩放当作“计数”，并用泊松分布的 Hellinger 距离近似 d(·)。
    （式(9)(10) 是对分布 L2 距离的积分，数值求积很慢；Hellinger 对 Poisson 有解析、单调近似。）

    返回：去噪后的梯度场 Gx, Gy
    """
    H, W = Gx_prime.shape
    Gmag = np.sqrt(Gx_prime*Gx_prime + Gy_prime*Gy_prime)

    # 映射到“计数”域（非负），典型均值在 10~50 之间较稳
    lam_img = np.clip(Gmag * count_scale, 0, None).astype(np.float32)

    # 预计算积分图，快速取 patch 均值（极大似然估计 λ̂，式(8)）
    ksz = 2*patch_radius + 1
    ones = np.ones((H, W), np.float32)
    sum_lam = cv2.boxFilter(lam_img, ddepth=-1, ksize=(ksz, ksz), borderType=cv2.BORDER_REFLECT) * (ksz*ksz)
    # 上一行是总和（用均值 * 面积），也可直接 boxFilter 两次取总和，这里省一次算

    # 结果
    Gx = np.zeros_like(Gx_prime)
    Gy = np.zeros_like(Gy_prime)

    # 搜索窗
    sr = search_radius
    pr = patch_radius
    area = float((2*pr+1)*(2*pr+1))

    # 辅助：Hellinger 距离的简化（对 Poisson 参数 λx, λy： d_H^2 ≈ (sqrt(λx)-sqrt(λy))^2 ）
    # 作为式(9)(10)的可计算近似项，保持对 λ 的单调性
    sqrt_lam = np.sqrt(lam_img + 1e-8)

    for y in range(H):
        y0, y1 = max(0, y-pr), min(H, y+pr+1)
        for x in range(W):
            x0, x1 = max(0, x-pr), min(W, x+pr+1)

            # 中心 patch 的 λ̂x（用 patch 均值近似，式(8)）
            cx0, cx1 = x0, x1; cy0, cy1 = y0, y1
            lam_x_hat = sum_lam[y, x] / area
            lam_x_hat = max(lam_x_hat, 1e-8)

            # 搜索窗范围
            sy0, sy1 = max(pr, y-sr), min(H-pr, y+sr+1)
            sx0, sx1 = max(pr, x-sr), min(W-pr, x+sr+1)

            # 收集候选
            weights = []
            coords = []
            for yy in range(sy0, sy1):
                for xx in range(sx0, sx1):
                    # 邻点 patch 的 λ̂y
                    lam_y_hat = sum_lam[yy, xx] / area

                    # d(λx,λy) 近似：Hellinger^2
                    d = (np.sqrt(lam_x_hat) - np.sqrt(lam_y_hat))**2

                    # 权重（式(12)的简化版本：单一 d / (ρ λx)）
                    w = np.exp(- d / (rho * lam_x_hat))
                    weights.append(w); coords.append((yy, xx))

            # 取 top-k
            if len(weights) > topk:
                idx = np.argpartition(weights, -topk)[-topk:]
            else:
                idx = np.arange(len(weights))

            w_sel = np.array([weights[i] for i in idx], dtype=np.float32) + 1e-12
            c_sel = [coords[i] for i in idx]
            w_sel /= w_sel.sum()

            # 用相同权重加权 G' 的向量分量（式(11)）
            Gx_val = 0.0; Gy_val = 0.0
            for w, (yy, xx) in zip(w_sel, c_sel):
                Gx_val += w * Gx_prime[yy, xx]
                Gy_val += w * Gy_prime[yy, xx]
            Gx[y, x] = Gx_val; Gy[y, x] = Gy_val

    return Gx, Gy

# ---------- Step 3：变分重建（式(13)(14)(15)(16)) ----------
def variational_reconstruct(R, Gx, Gy,
                            gamma=0.2,   # γ
                            delta=0.8,   # δ
                            iters=10,    # n
                            dt=0.15):    # Δt（稳定性考虑取 0.1~0.2）
    """
    最小化：E(I)= γ∫||∇I|| + δ∫||∇I - G||^2
    I^{n+1} = I^n - Δt [ γ div(∇I/|∇I|) + 2δ (ΔI - div G) ]
    并裁剪到[0,255]（式(16)）
    """
    I = _normalize_to_255(R)

    for _ in range(iters):
        Ix, Iy = _grad2d(I)
        grad_norm = np.sqrt(Ix*Ix + Iy*Iy) + 1e-8
        # TV 项的“单位梯度”：
        px = Ix / grad_norm
        py = Iy / grad_norm

        div_p = _div2d(px, py)
        lap_I = _laplace(I)
        div_G = _div2d(Gx, Gy)

        Itemp = I - dt * (gamma * div_p + 2.0 * delta * (lap_I - div_G))

        # 像论文那样裁剪到 [0,255]（式(16)）
        I = np.clip(Itemp, 0.0, 255.0)

    return I.astype(np.uint8)

# ---------- 整体封装 ----------
def enhance_xray_poisson_nlm(R,
                             eps=2.3, mu=10.0, rho=1.5,
                             gamma=0.2, delta=0.8,
                             iters=10,
                             search_radius=5, patch_radius=1, topk=25):
    Gx_p, Gy_p = adaptive_gradient_enhance(R, epsilon=eps, mu=mu, ksize=5)
    Gx, Gy = poisson_nlm_on_gradient(Gx_p, Gy_p,
                                     search_radius=search_radius,
                                     patch_radius=patch_radius,
                                     topk=topk,
                                     rho=rho)
    I = variational_reconstruct(R, Gx, Gy,
                                gamma=gamma, delta=delta, iters=iters, dt=0.15)
    return I, (Gx_p, Gy_p), (Gx, Gy)
```

------

# 4) 在你框架中的对接方式

你现有 DICOM 加载（C#/C++/Python 任一语言）得到 `np.ndarray` 后，直接：

```python
# R: 你的 DICOM 像素（2D numpy array）
I_enh, (Gx_p, Gy_p), (Gx, Gy) = enhance_xray_poisson_nlm(
    R,
    eps=2.3, mu=10.0, rho=1.5,
    gamma=0.2, delta=0.8,
    iters=10,
    search_radius=5, patch_radius=1, topk=25
)

# I_enh 即最终增强图（8-bit），可直接显示/保存；
# 也可按你框架需求映射回 16-bit 或窗口显示。
```

------

# 5) 重要实现细节与理由（和论文一致性）

- **为何在梯度域做增强与去噪**：梯度对轮廓敏感，用局部方差门控的增益函数 k(σ2)k(\sigma^2) 减少对噪声的放大；σ2>ε\sigma^2>\varepsilon 仅在高频区放大（式(2)(5)(6)）。 

- **Poisson-NLM 的实现取舍**：原式(9)(10)是对两泊松分布差异的积分，直接数值积分计算量大。这里用**Hellinger 距离对泊松参数的解析近似** dH2 ⁣≈(λx−λy)2d_H^2\!\approx(\sqrt{\lambda_x}-\sqrt{\lambda_y})^2 来近似权重中的 d(⋅)d(\cdot)（式(12)），保持与 λ\lambda 的单调关系，实践中稳健可用。权重形式沿用 exp⁡(−d/(ρλx))\exp(-d/(\rho\lambda_x))（式(12)）。

  > 如果你更倾向“完全遵循论文式(9)(10)”，可以把 `d` 换成对 rr 的有限上界数值求积或查表，但速度会慢很多。

- **变分重建**：TV 正则 + 梯度对齐项（式(13)），离散化用 div(∇I/∣∇I∣)\text{div}(\nabla I / |\nabla I|)、ΔI\Delta I、divG\text{div}G（式(14)），梯度下降（式(15)），每步裁剪（式(16)）。  

- **默认参数**：按文中推荐 n=10, ε=2.3, μ=10, ρ=1.5, γ=0.2, δ=0.8n=10,\ \varepsilon=2.3,\ \mu=10,\ \rho=1.5,\ \gamma=0.2,\ \delta=0.8。你可以把它们暴露到 UI。

------

# 6) 性能与工程化建议

- 上面的 Poisson-NLM 是**直观、易读**实现，便于你先验证效果；若要上实时：
  1. 只在**高方差区域**做 NLM，其余直接传递 G′G'。
  2. 限制 `search_radius=3`、`topk=10`。
  3. 预先对整幅图做**块状**处理、向量化或用 `numba`/C++ 改写权重计算。
  4. 或采用**Anscombe 变换**把泊松近似成高斯，再用现成 `NLMeans`（会偏离论文设定，但快）。
- DICOM 16-bit 量纲：本实现前面 `_normalize_to_255` 做了稳健归一，ε\varepsilon 等阈值因此具有可移植性。若你要保持 16-bit，可在输出时把 `I_enh/255 * 原窗宽 + 原窗位` 做回映射。

------

# 7) 快速回归测试（建议）

- 按论文指标做一个小验证脚本：AG、SE、EAV（文中客观指标部分），对比 CLAHE 或你现有增强的指标变化；数据可用你已有的一两张工件图先跑一下，观察细节区域是否既锐且稳噪。

------

如果你愿意，我可以**把 Step1/2/3 拆成你 C# 项目可直接调用的伪代码/流程**（OpenCvSharp 版），或者把上面 Python 里的 NLM 核心权重换成**严格按式(9)(10)的数值积分**版本（慢一点但更贴原式）。你更倾向哪种？